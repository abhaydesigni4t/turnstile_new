Ansar Ahmed
ULTIMATE DESIGN TECHNOLOGY LLP
EE
1173919287
1173919287
Mumbai
ansar@mail.com

make parameter dynamic
************************

first read all as a expert
this is multiple sites project i have admin that perform every curd operation on data now i created sub-admin 
this is view to create sub admin "@login_required
def create_subadmin(request):
    if request.method == 'POST':
        form = SubAdminCreationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.is_staff = True  # Set the user as a staff member
            user.is_superuser = False  # Ensure the user is not a superuser
            user.set_password(form.cleaned_data['password'])
            user.save()

            # Save the many-to-many data for the 'sites' field
            sites = form.cleaned_data['sites']
            user.sites.set(sites)  # Assuming you have a 'sites' field in your CustomUser model

            return redirect('subadmin_success')  # Replace with your success URL name
        else:
            # Handle form errors
            return render(request, 'app1/create_subadmin.html', {'form': form, 'errors': form.errors})
    else:
        form = SubAdminCreationForm()
    return render(request, 'app1/create_subadmin.html', {'form': form})" 
    this is sub admin form "class SubAdminCreationForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput, required=True)
    sites = forms.ModelMultipleChoiceField(
        queryset=Site.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False,
    )

    class Meta:
        model = CustomUser
        fields = ['email', 'name', 'company_name', 'job_role', 'mycompany_id', 'tag_id', 'job_location', 'password', 'sites']"

    so i want to give permission to sub admin that sub admin only perform curd operation on selected site
    when sub-admin login then show selected sites only other site make disable 

    this is login view sub admin login through this view "@csrf_protect
    def login_view_new(request):
        if request.method == 'POST':
            form = LoginForm_new(request.POST)
            if form.is_valid():
                # Convert email to lowercase before authentication
                email = form.cleaned_data.get('email').lower()
                password = form.cleaned_data.get('password')
                user = authenticate(request, email=email, password=password)
                if user is not None:
                    login(request, user)
                    messages.success(request, 'Login successful.')
                    return redirect('sites')
                else:
                    messages.error(request, 'Invalid email or password.')
        else:
            form = LoginForm_new()
        return render(request, 'app1/signup.html', {'form': form, 'is_login_page': True})" 

this is site model ""









could not fetch file contents

**********************************

i want to give same site name that exist in site model 
here this api takes site value like site : 2 
this is model "class UserEnrolled(models.Model):
sr = models.AutoField(primary_key=True, unique=True)
picture = models.ImageField(upload_to='user_pictures/', blank=True, null=True)
name = models.CharField(max_length=255)
company_name = models.CharField(max_length=100)
job_role = models.CharField(max_length=100)
mycompany_id = models.CharField(max_length=10)
tag_id = models.CharField(max_length=50)
job_location = models.CharField(max_length=100)
orientation = models.FileField(upload_to='attachments/', blank=True, null=True, validators=[FileExtensionValidator(['jpeg', 'jpg'])])
facial_data = models.ImageField(upload_to=user_image_upload_path, blank=True, null=True, verbose_name='Facial Data')
my_comply = models.ImageField(upload_to='compliance_images/', blank=True, null=True)
expiry_date = models.DateField(blank=True, null=True)
status = models.CharField(max_length=100, choices=[
    ('active', 'Active'),
    ('inactive', 'Inactive'),
], default='active')
email = models.EmailField()
password = models.CharField(max_length=50)
site = models.ForeignKey('Site', on_delete=models.CASCADE, blank=True, null=True)

def _str_(self):
    return self.name

def get_folder_name(self):
    return self.name

def set_password(self, raw_password):
    self.password = make_password(raw_password)

def check_password(self, raw_password):
    return check_password(raw_password, self.password)"

this is api "class update_user_api(APIView):

def put(self, request, *args, **kwargs):
    return self.update_user(request)

def patch(self, request, *args, **kwargs):
    return self.update_user(request, partial=True)

def update_user(self, request, partial=False):
    email = request.data.get('email')
    if not email:
        return Response({"detail": "Email parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user_enrolled = UserEnrolled.objects.get(email=email)
    except UserEnrolled.DoesNotExist:
        return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)

    # Use the serializer to validate and update data
    serializer = UpdateEnrolledSerializer(user_enrolled, data=request.data, partial=partial)
    if serializer.is_valid():
        updated_fields = self.perform_update(serializer, request, user_enrolled)
        response_data = {field: serializer.data[field] for field in updated_fields}
        response_data = self.add_full_image_urls(response_data, user_enrolled)
        return Response(response_data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

def perform_update(self, serializer, request, user_enrolled):
    # Save the instance while keeping the password unchanged
    instance = serializer.instance
    password = instance.password
    serializer.save(password=password)

    # Ensure the user's folder exists
    user_folder = os.path.join(settings.MEDIA_ROOT, 'facial_data', user_enrolled.get_folder_name())
    os.makedirs(user_folder, exist_ok=True)

    # Update `facial_data` specifically
    if 'facial_data' in request.FILES:
        file = request.FILES['facial_data']
        file_path = os.path.join(user_folder, file.name)
        with open(file_path, 'wb+') as destination:
            for chunk in file.chunks():
                destination.write(chunk)
        instance.facial_data = file_path
        instance.picture = file_path  # Update the picture field as well
        instance.save()

    # Get the list of updated fields
    return serializer.validated_data.keys()

def add_full_image_urls(self, data, instance):
    # Add full URLs for image fields
    request = self.request
    if 'picture' in data:
        data['picture'] = request.build_absolute_uri(instance.picture.url)
    if 'orientation' in data:
        data['orientation'] = request.build_absolute_uri(instance.orientation.url)
    if 'facial_data' in data:
        data['facial_data'] = request.build_absolute_uri(instance.facial_data.url)
    if 'my_comply' in data:
        data['my_comply'] = request.build_absolute_uri(instance.my_comply.url)
    return data
" 
this is serializer "class UpdateEnrolledSerializer(serializers.ModelSerializer):
class Meta:
    model = UserEnrolled
    exclude = ['password']" 

userenrolled model having relation with site model this is site model "class Site(models.Model):
picture = models.ImageField(upload_to='site_pictures/', blank=True, null=True)
name = models.CharField(max_length=100,unique=True)
location = models.CharField(max_length=100)

def save(self, *args, **kwargs):
    self.name = self.name.upper()
    super(Site, self).save(*args, **kwargs)
    
def __str__(self):
    return self.name"