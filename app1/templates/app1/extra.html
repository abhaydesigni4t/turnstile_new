Ansar Ahmed
ULTIMATE DESIGN TECHNOLOGY LLP
EE
1173919287
1173919287
Mumbai
ansar@mail.com

make parameter dynamic
************************

first read all as a expert
this is multiple sites project i have admin that perform every curd operation on data now i created sub-admin 
this is view to create sub admin "@login_required
def create_subadmin(request):
    if request.method == 'POST':
        form = SubAdminCreationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.is_staff = True  # Set the user as a staff member
            user.is_superuser = False  # Ensure the user is not a superuser
            user.set_password(form.cleaned_data['password'])
            user.save()

            # Save the many-to-many data for the 'sites' field
            sites = form.cleaned_data['sites']
            user.sites.set(sites)  # Assuming you have a 'sites' field in your CustomUser model

            return redirect('subadmin_success')  # Replace with your success URL name
        else:
            # Handle form errors
            return render(request, 'app1/create_subadmin.html', {'form': form, 'errors': form.errors})
    else:
        form = SubAdminCreationForm()
    return render(request, 'app1/create_subadmin.html', {'form': form})" 
    this is sub admin form "class SubAdminCreationForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput, required=True)
    sites = forms.ModelMultipleChoiceField(
        queryset=Site.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False,
    )

    class Meta:
        model = CustomUser
        fields = ['email', 'name', 'company_name', 'job_role', 'mycompany_id', 'tag_id', 'job_location', 'password', 'sites']"

    so i want to give permission to sub admin that sub admin only perform curd operation on selected site
    when sub-admin login then show selected sites only other site make disable 

    this is login view sub admin login through this view "@csrf_protect
    def login_view_new(request):
        if request.method == 'POST':
            form = LoginForm_new(request.POST)
            if form.is_valid():
                # Convert email to lowercase before authentication
                email = form.cleaned_data.get('email').lower()
                password = form.cleaned_data.get('password')
                user = authenticate(request, email=email, password=password)
                if user is not None:
                    login(request, user)
                    messages.success(request, 'Login successful.')
                    return redirect('sites')
                else:
                    messages.error(request, 'Invalid email or password.')
        else:
            form = LoginForm_new()
        return render(request, 'app1/signup.html', {'form': form, 'is_login_page': True})" 

        this is login form "
        class LoginForm_new(forms.Form):
            email = forms.EmailField(max_length=254, required=True)
            password = forms.CharField(widget=forms.PasswordInput, required=True)"

this is site model "class Site(models.Model):
picture = models.ImageField(upload_to='site_pictures/', blank=True, null=True)
name = models.CharField(max_length=100,unique=True)
location = models.CharField(max_length=100)

def save(self, *args, **kwargs):
    self.name = self.name.upper()
    super(Site, self).save(*args, **kwargs)
    
def __str__(self):
    return self.name"









yes in asset management , onsite user function is write code of get site_name 
see this is asset get view "def asset_site(request):
site_name = request.GET.get('site_name')
if site_name:
    try:
        site = Site.objects.get(name=site_name)
        assets = Asset.objects.filter(site=site)
    except Site.DoesNotExist:
        assets = Asset.objects.none()
else:
    assets = Asset.objects.all()

paginator = Paginator(assets, 8)
page_number = request.GET.get('page')
assets = paginator.get_page(page_number)

sites = Site.objects.all()

return render(request, 'app1/asset_site.html', {'assets': assets, 'sites': sites, 'selected_site_name': site_name})"

this is onsite user get view "def onsite_user(request):
site_name = request.GET.get('site_name')
queryset = OnSiteUser.objects.all()

if site_name:
    try:
        site = Site.objects.get(name=site_name)
        queryset = queryset.filter(site=site)
        print(f"Site found: {site.name}")  # Debugging print statement
    except Site.DoesNotExist:
        queryset = OnSiteUser.objects.none()
        print(f"Site not found: {site_name}")  # Debugging print statement

paginator = Paginator(queryset, 10)  # 10 items per page
page_number = request.GET.get('page')
on_site_users = paginator.get_page(page_number)

sites = Site.objects.all()  # Get all sites to display in the template

return render(request, 'app1/onsite_user.html', {'on_site_users': on_site_users, 'sites': sites, 'selected_site_name': site_name})
"
 this view perform correctly 

 so now modify get view of reports , noticications,company and Documents

 this is get Analytics and repost view "def report_view(request):
 try:
     active_users = UserEnrolled.objects.filter(status='active').count()
     inactive_users = UserEnrolled.objects.filter(status='inactive').count()

     labels = ['Active', 'Inactive']
     sizes = [active_users, inactive_users]
     colors = ['#4CAF50', '#F44336'] 

     plt.figure(figsize=(6, 6))
     plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)
     #plt.title('User Status')
     plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

     chart_filename = 'pie_chart.png'
     chart_path = os.path.join(settings.MEDIA_ROOT, chart_filename)
     plt.savefig(chart_path)

     chart_url = os.path.join(settings.MEDIA_URL, chart_filename)
     return render(request, 'app1/report.html', {'chart_url': chart_url})
 except Exception as e:
     print(f"An error occurred: {e}")
     return render(request, 'app1/error.html', {'error_message': str(e)})"

     this is get notification view "
     def notification_view(request):
         noti_data =  Notification.objects.all() 
         return render(request, 'app1/notification1.html', {'noti_data': noti_data})"

    this is company get view "def company_view(request):
    compy = company.objects.all() 
    return render(request, 'app1/company.html', {'compy': compy})"

    and this is document get view "def orientation_task(request):
    if request.method == 'POST':
        form = OrientationForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()
            return render(request, 'app1/success1.html')
        else:
            print(form.errors)
    else:
        form = OrientationForm()

    latest_orientation = Orientation.objects.last()
    return render(request, 'app1/orientation.html', {'form': form, 'latest_orientation': latest_orientation})" 

    so modify this all view for show correct site data


**********************************

this api work correctly only problem is that this api must want 1 field from orientation,facial_data,my_comply
 i don't want like this i want api that update any single field or update multiple field
like i don't want to update orientation,facial_data,my_comply then i not pass this but now if i am not pass 1 field from
orientation,facial_data,my_comply then it return 500 error check api and modify 
this is model "class UserEnrolled(models.Model):
sr = models.AutoField(primary_key=True, unique=True)
picture = models.ImageField(upload_to='user_pictures/', blank=True, null=True)
name = models.CharField(max_length=255)
company_name = models.CharField(max_length=100)
job_role = models.CharField(max_length=100)
mycompany_id = models.CharField(max_length=10)
tag_id = models.CharField(max_length=50)
job_location = models.CharField(max_length=100)
orientation = models.FileField(upload_to='attachments/', blank=True, null=True, validators=[FileExtensionValidator(['jpeg', 'jpg'])])
facial_data = models.ImageField(upload_to=user_image_upload_path, blank=True, null=True, verbose_name='Facial Data')
my_comply = models.ImageField(upload_to='compliance_images/', blank=True, null=True)
expiry_date = models.DateField(blank=True, null=True)
status = models.CharField(max_length=100, choices=[
    ('active', 'Active'),
    ('inactive', 'Inactive'),
], default='active')
email = models.EmailField()
password = models.CharField(max_length=50)
site = models.ForeignKey('Site', on_delete=models.CASCADE, blank=True, null=True)

def _str_(self):
    return self.name

def get_folder_name(self):
    return self.name

def set_password(self, raw_password):
    self.password = make_password(raw_password)

def check_password(self, raw_password):
    return check_password(raw_password, self.password)"

this is update api "class update_user_api(APIView):

def put(self, request, *args, **kwargs):
    return self.update_user(request)

def patch(self, request, *args, **kwargs):
    return self.update_user(request, partial=True)

def update_user(self, request, partial=False):
    email = request.data.get('email')
    if not email:
        return Response({"detail": "Email parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user_enrolled = UserEnrolled.objects.get(email=email)
    except UserEnrolled.DoesNotExist:
        return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)

    # Handle site name
    site_name = request.data.get('site')
    if site_name:
        try:
            site = Site.objects.get(name=site_name.upper())
            request.data['site'] = site.id
        except Site.DoesNotExist:
            return Response({"detail": "Site with the given name does not exist."}, status=status.HTTP_400_BAD_REQUEST)

    # Use the serializer to validate and update data
    serializer = UpdateEnrolledSerializer(user_enrolled, data=request.data, partial=partial)
    if serializer.is_valid():
        updated_fields = self.perform_update(serializer, request, user_enrolled)
        response_data = {field: serializer.data[field] for field in updated_fields}
        response_data = self.add_full_image_urls(response_data, user_enrolled)
        return Response(response_data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

def perform_update(self, serializer, request, user_enrolled):
    # Save the instance while keeping the password unchanged
    instance = serializer.instance
    password = instance.password
    serializer.save(password=password)

    # Ensure the user's folder exists
    user_folder = os.path.join(settings.MEDIA_ROOT, 'facial_data', user_enrolled.get_folder_name())
    os.makedirs(user_folder, exist_ok=True)

    # Update `facial_data` specifically
    if 'facial_data' in request.FILES:
        file = request.FILES['facial_data']
        file_path = os.path.join(user_folder, file.name)
        with open(file_path, 'wb+') as destination:
            for chunk in file.chunks():
                destination.write(chunk)
        instance.facial_data = file_path
        instance.picture = file_path  # Update the picture field as well
        instance.save()

    # Get the list of updated fields
    return serializer.validated_data.keys()

def add_full_image_urls(self, data, instance):
    # Add full URLs for image fields
    request = self.request
    if 'picture' in data:
        data['picture'] = request.build_absolute_uri(instance.picture.url)
    if 'orientation' in data:
        data['orientation'] = request.build_absolute_uri(instance.orientation.url)
    if 'facial_data' in data:
        data['facial_data'] = request.build_absolute_uri(instance.facial_data.url)
    if 'my_comply' in data:
        data['my_comply'] = request.build_absolute_uri(instance.my_comply.url)

    # Add site name to the response
    if instance.site:
        data['site'] = instance.site.name

    return data
"
this is serializer "class UpdateEnrolledSerializer(serializers.ModelSerializer):
class Meta:
    model = UserEnrolled
    exclude = ['password']"




*************************


modify this api i want in response only updated field 
"class UserEnrolledUpdateAPIView_n(generics.UpdateAPIView):
queryset = UserEnrolled.objects.all()
serializer_class = UserEnrolledSerializer_update

def get_object(self):
    email = self.request.data.get('email')
    if email is None:
        raise serializers.ValidationError("Email parameter is required for update.")
    return get_object_or_404(UserEnrolled, email=email)

def update(self, request, *args, **kwargs):
    # Get the instance that needs to be updated
    instance = self.get_object()

    # Ensure that the password field is not updated
    data = request.data.copy()
    if 'password' in data:
        data.pop('password')

    # Validate and retrieve the site if provided
    site_name = data.get('site', None)
    if site_name:
        try:
            site = Site.objects.get(name=site_name)
            data['site'] = site
        except Site.DoesNotExist:
            return Response({"error": "The specified site does not exist."}, status=status.HTTP_400_BAD_REQUEST)

    # Create the serializer with the updated data
    serializer = self.get_serializer(instance, data=data, partial=True)
    serializer.is_valid(raise_exception=True)

    # Save the instance
    self.perform_update(serializer)

    # Return the entire updated instance
    instance = self.get_object()  # Refresh the instance to get all fields
    serializer = self.get_serializer(instance)
    return Response(serializer.data)

def perform_update(self, serializer):
    serializer.save(password=self.get_object().password)  # Keep the original password" 
    this is serializer "    
    class UserEnrolledSerializer_update(serializers.ModelSerializer):
        class Meta:
            model = UserEnrolled
            fields = '__all__'  # Or specify the fields you want to include
            read_only_fields = ('password',)  # Make sure password cannot be updated"