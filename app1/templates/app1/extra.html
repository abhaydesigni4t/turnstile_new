Ansar Ahmed
ULTIMATE DESIGN TECHNOLOGY LLP
EE
1173919287
1173919287
Mumbai
ansar@mail.com

make parameter dynamic
************************

first read all as a expert
this is multiple sites project i have admin that perform every curd operation on data now i created sub-admin 
this is view to create sub admin "@login_required
def create_subadmin(request):
    if request.method == 'POST':
        form = SubAdminCreationForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.is_staff = True  # Set the user as a staff member
            user.is_superuser = False  # Ensure the user is not a superuser
            user.set_password(form.cleaned_data['password'])
            user.save()

            # Save the many-to-many data for the 'sites' field
            sites = form.cleaned_data['sites']
            user.sites.set(sites)  # Assuming you have a 'sites' field in your CustomUser model

            return redirect('subadmin_success')  # Replace with your success URL name
        else:
            # Handle form errors
            return render(request, 'app1/create_subadmin.html', {'form': form, 'errors': form.errors})
    else:
        form = SubAdminCreationForm()
    return render(request, 'app1/create_subadmin.html', {'form': form})" 
    this is sub admin form "class SubAdminCreationForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput, required=True)
    sites = forms.ModelMultipleChoiceField(
        queryset=Site.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False,
    )

    class Meta:
        model = CustomUser
        fields = ['email', 'name', 'company_name', 'job_role', 'mycompany_id', 'tag_id', 'job_location', 'password', 'sites']"

    so i want to give permission to sub admin that sub admin only perform curd operation on selected site
    when sub-admin login then show selected sites only other site make disable 

    this is login view sub admin login through this view "@csrf_protect
    def login_view_new(request):
        if request.method == 'POST':
            form = LoginForm_new(request.POST)
            if form.is_valid():
                # Convert email to lowercase before authentication
                email = form.cleaned_data.get('email').lower()
                password = form.cleaned_data.get('password')
                user = authenticate(request, email=email, password=password)
                if user is not None:
                    login(request, user)
                    messages.success(request, 'Login successful.')
                    return redirect('sites')
                else:
                    messages.error(request, 'Invalid email or password.')
        else:
            form = LoginForm_new()
        return render(request, 'app1/signup.html', {'form': form, 'is_login_page': True})" 

        this is login form "
        class LoginForm_new(forms.Form):
            email = forms.EmailField(max_length=254, required=True)
            password = forms.CharField(widget=forms.PasswordInput, required=True)"

this is site model "class Site(models.Model):
picture = models.ImageField(upload_to='site_pictures/', blank=True, null=True)
name = models.CharField(max_length=100,unique=True)
location = models.CharField(max_length=100)

def save(self, *args, **kwargs):
    self.name = self.name.upper()
    super(Site, self).save(*args, **kwargs)
    
def __str__(self):
    return self.name"









yes in asset management , onsite user function is write code of get site_name 
see this is asset get view "def asset_site(request):
site_name = request.GET.get('site_name')
if site_name:
    try:
        site = Site.objects.get(name=site_name)
        assets = Asset.objects.filter(site=site)
    except Site.DoesNotExist:
        assets = Asset.objects.none()
else:
    assets = Asset.objects.all()

paginator = Paginator(assets, 8)
page_number = request.GET.get('page')
assets = paginator.get_page(page_number)

sites = Site.objects.all()

return render(request, 'app1/asset_site.html', {'assets': assets, 'sites': sites, 'selected_site_name': site_name})"

this is onsite user get view "def onsite_user(request):
site_name = request.GET.get('site_name')
queryset = OnSiteUser.objects.all()

if site_name:
    try:
        site = Site.objects.get(name=site_name)
        queryset = queryset.filter(site=site)
        print(f"Site found: {site.name}")  # Debugging print statement
    except Site.DoesNotExist:
        queryset = OnSiteUser.objects.none()
        print(f"Site not found: {site_name}")  # Debugging print statement

paginator = Paginator(queryset, 10)  # 10 items per page
page_number = request.GET.get('page')
on_site_users = paginator.get_page(page_number)

sites = Site.objects.all()  # Get all sites to display in the template

return render(request, 'app1/onsite_user.html', {'on_site_users': on_site_users, 'sites': sites, 'selected_site_name': site_name})
"
 this view perform correctly 

 so now modify get view of reports , noticications,company and Documents

 this is get Analytics and repost view "def report_view(request):
 try:
     active_users = UserEnrolled.objects.filter(status='active').count()
     inactive_users = UserEnrolled.objects.filter(status='inactive').count()

     labels = ['Active', 'Inactive']
     sizes = [active_users, inactive_users]
     colors = ['#4CAF50', '#F44336'] 

     plt.figure(figsize=(6, 6))
     plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)
     #plt.title('User Status')
     plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.

     chart_filename = 'pie_chart.png'
     chart_path = os.path.join(settings.MEDIA_ROOT, chart_filename)
     plt.savefig(chart_path)

     chart_url = os.path.join(settings.MEDIA_URL, chart_filename)
     return render(request, 'app1/report.html', {'chart_url': chart_url})
 except Exception as e:
     print(f"An error occurred: {e}")
     return render(request, 'app1/error.html', {'error_message': str(e)})"

     this is get notification view "
     def notification_view(request):
         noti_data =  Notification.objects.all() 
         return render(request, 'app1/notification1.html', {'noti_data': noti_data})"

    this is company get view "def company_view(request):
    compy = company.objects.all() 
    return render(request, 'app1/company.html', {'compy': compy})"

    and this is document get view "def orientation_task(request):
    if request.method == 'POST':
        form = OrientationForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()
            return render(request, 'app1/success1.html')
        else:
            print(form.errors)
    else:
        form = OrientationForm()

    latest_orientation = Orientation.objects.last()
    return render(request, 'app1/orientation.html', {'form': form, 'latest_orientation': latest_orientation})" 

    so modify this all view for show correct site data


**********************************

this api work correctly only problem is that this api must want 1 field from orientation,facial_data,my_comply
 i don't want like this i want api that update any single field or update multiple field
like i don't want to update orientation,facial_data,my_comply then i not pass this but now if i am not pass 1 field from
orientation,facial_data,my_comply then it return 500 error check api and modify 
this is model "class UserEnrolled(models.Model):
sr = models.AutoField(primary_key=True, unique=True)
picture = models.ImageField(upload_to='user_pictures/', blank=True, null=True)
name = models.CharField(max_length=255)
company_name = models.CharField(max_length=100)
job_role = models.CharField(max_length=100)
mycompany_id = models.CharField(max_length=10)
tag_id = models.CharField(max_length=50)
job_location = models.CharField(max_length=100)
orientation = models.FileField(upload_to='attachments/', blank=True, null=True, validators=[FileExtensionValidator(['jpeg', 'jpg'])])
facial_data = models.ImageField(upload_to=user_image_upload_path, blank=True, null=True, verbose_name='Facial Data')
my_comply = models.ImageField(upload_to='compliance_images/', blank=True, null=True)
expiry_date = models.DateField(blank=True, null=True)
status = models.CharField(max_length=100, choices=[
    ('active', 'Active'),
    ('inactive', 'Inactive'),
], default='active')
email = models.EmailField()
password = models.CharField(max_length=50)
site = models.ForeignKey('Site', on_delete=models.CASCADE, blank=True, null=True)

def _str_(self):
    return self.name

def get_folder_name(self):
    return self.name

def set_password(self, raw_password):
    self.password = make_password(raw_password)

def check_password(self, raw_password):
    return check_password(raw_password, self.password)"

this is update api "class update_user_api(APIView):

def put(self, request, *args, **kwargs):
    return self.update_user(request)

def patch(self, request, *args, **kwargs):
    return self.update_user(request, partial=True)

def update_user(self, request, partial=False):
    email = request.data.get('email')
    if not email:
        return Response({"detail": "Email parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

    try:
        user_enrolled = UserEnrolled.objects.get(email=email)
    except UserEnrolled.DoesNotExist:
        return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)

    # Handle site name
    site_name = request.data.get('site')
    if site_name:
        try:
            site = Site.objects.get(name=site_name.upper())
            request.data['site'] = site.id
        except Site.DoesNotExist:
            return Response({"detail": "Site with the given name does not exist."}, status=status.HTTP_400_BAD_REQUEST)

    # Use the serializer to validate and update data
    serializer = UpdateEnrolledSerializer(user_enrolled, data=request.data, partial=partial)
    if serializer.is_valid():
        updated_fields = self.perform_update(serializer, request, user_enrolled)
        response_data = {field: serializer.data[field] for field in updated_fields}
        response_data = self.add_full_image_urls(response_data, user_enrolled)
        return Response(response_data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

def perform_update(self, serializer, request, user_enrolled):
    # Save the instance while keeping the password unchanged
    instance = serializer.instance
    password = instance.password
    serializer.save(password=password)

    # Ensure the user's folder exists
    user_folder = os.path.join(settings.MEDIA_ROOT, 'facial_data', user_enrolled.get_folder_name())
    os.makedirs(user_folder, exist_ok=True)

    # Update `facial_data` specifically
    if 'facial_data' in request.FILES:
        file = request.FILES['facial_data']
        file_path = os.path.join(user_folder, file.name)
        with open(file_path, 'wb+') as destination:
            for chunk in file.chunks():
                destination.write(chunk)
        instance.facial_data = file_path
        instance.picture = file_path  # Update the picture field as well
        instance.save()

    # Get the list of updated fields
    return serializer.validated_data.keys()

def add_full_image_urls(self, data, instance):
    # Add full URLs for image fields
    request = self.request
    if 'picture' in data:
        data['picture'] = request.build_absolute_uri(instance.picture.url)
    if 'orientation' in data:
        data['orientation'] = request.build_absolute_uri(instance.orientation.url)
    if 'facial_data' in data:
        data['facial_data'] = request.build_absolute_uri(instance.facial_data.url)
    if 'my_comply' in data:
        data['my_comply'] = request.build_absolute_uri(instance.my_comply.url)

    # Add site name to the response
    if instance.site:
        data['site'] = instance.site.name

    return data
"
this is serializer "class UpdateEnrolledSerializer(serializers.ModelSerializer):
class Meta:
    model = UserEnrolled
    exclude = ['password']"




*************************


modify this api i want in response only updated field 
"class UserEnrolledUpdateAPIView_n(generics.UpdateAPIView):
queryset = UserEnrolled.objects.all()
serializer_class = UserEnrolledSerializer_update

def get_object(self):
    email = self.request.data.get('email')
    if email is None:
        raise serializers.ValidationError("Email parameter is required for update.")
    return get_object_or_404(UserEnrolled, email=email)

def update(self, request, *args, **kwargs):
    # Get the instance that needs to be updated
    instance = self.get_object()

    # Ensure that the password field is not updated
    data = request.data.copy()
    if 'password' in data:
        data.pop('password')

    # Validate and retrieve the site if provided
    site_name = data.get('site', None)
    if site_name:
        try:
            site = Site.objects.get(name=site_name)
            data['site'] = site
        except Site.DoesNotExist:
            return Response({"error": "The specified site does not exist."}, status=status.HTTP_400_BAD_REQUEST)

    # Create the serializer with the updated data
    serializer = self.get_serializer(instance, data=data, partial=True)
    serializer.is_valid(raise_exception=True)

    # Save the instance
    self.perform_update(serializer)

    # Return the entire updated instance
    instance = self.get_object()  # Refresh the instance to get all fields
    serializer = self.get_serializer(instance)
    return Response(serializer.data)

def perform_update(self, serializer):
    serializer.save(password=self.get_object().password)  # Keep the original password" 
    this is serializer "    
    class UserEnrolledSerializer_update(serializers.ModelSerializer):
        class Meta:
            model = UserEnrolled
            fields = '__all__'  # Or specify the fields you want to include
            read_only_fields = ('password',)  # Make sure password cannot be updated"


*****************************



def asset_site(request):
    site_name = request.GET.get('site_name')
    if site_name:
        try:
            site = Site.objects.get(name=site_name)
            assets = Asset.objects.filter(site=site)
        except Site.DoesNotExist:
            assets = Asset.objects.none()
    else:
        assets = Asset.objects.all()

    paginator = Paginator(assets, 8)
    page_number = request.GET.get('page')
    assets = paginator.get_page(page_number)

    sites = Site.objects.all()

    return render(request, 'app1/asset_site.html', {'assets': assets, 'sites': sites, 'selected_site_name': site_name})



    def notification_view(request):
    site_name = request.GET.get('site_name')
    noti_data = Notification.objects.all()

    if site_name:
        try:
            site = Site.objects.get(name=site_name)
            noti_data = noti_data.filter(site=site)
        except Site.DoesNotExist:
            noti_data = Notification.objects.none()

    return render(request, 'app1/notification1.html', {'noti_data': noti_data, 'site_name': site_name})

************************************




Sure, let me explain how these modifications ensure that the site_name parameter is correctly 
handled across different views and templates:

Handling site_name in Views
Retrieving site_name Parameter:

In each view, we attempt to retrieve the site_name parameter from the URL query parameters 
using self.request.GET.get('site_name').
If site_name is not found in the URL, we then check the session 
using self.request.session.get('site_name').
Saving site_name in Session:

Once we have the site_name, we save it in the session using
 self.request.session['site_name'] = site_name. This allows us to retain the site_name across different 
 views even if it's not explicitly provided in the URL.
Using site_name for Filtering:

For views that need to filter data based on site_name, such as get_data, 
we use queryset = queryset.filter(site__name=site_name) to filter the queryset if site_name is present.
Passing site_name to Templates:

We pass the site_name to the template context using context['site_name'] = site_name. 
This ensures that the site_name is available in the templates for generating links.
Ensuring Links Pass site_name
Template Links:
In your templates, when generating links, we append the site_name parameter to the URL query string. 
For example:
html
Copy code
<a href="{% url 'asset_site' %}?site_name={{ site_name }}"><i class="fas fa-tasks"></i> Asset Management</a>
<a href="{% url 'site_docu' %}?site_name={{ site_name }}"><i class="fas fa-file-alt"></i> Site Documents</a>
<a href="{% url 'onsite_user' %}?site_name={{ site_name }}"><i class="fas fa-user-check"></i> On Site User</a>
<a href="{% url 'report' %}?site_name={{ site_name }}"><i class="fas fa-chart-bar"></i> Analytics & Reports</a>
<a href="{% url 'notification1' %}?site_name={{ site_name }}"><i class="fas fa-bell"></i> Notifications</a>
<a href="{% url 'company' %}?site_name={{ site_name }}"><i class="fas fa-building"></i> Company</a>
<a href="{% url 'orientation' %}?site_name={{ site_name }}"><i class="fas fa-file-alt"></i> Documents</a>
Example: get_data View
Here’s a detailed breakdown of the get_data view:

Class-based View:

The get_data view is a Django class-based view inheriting from ListView.
Queryset Filtering:

In the get_queryset method, we retrieve the site_name from the URL or session. If site_name is found,
 we filter the queryset based on site__name.
Passing Data to Template:

In the get_context_data method, we add the site_name to the context and ensure it's stored in the session
 if present.
Example: create_data View
The create_data view is similarly modified:

Class-based View:

The create_data view is a Django class-based view inheriting from CreateView.
Handling site_name:

In the get_context_data method, we retrieve the site_name from the URL or session and
 store it in the session if present. We also add the site_name to the context to make it 
 available in the template.
Ensuring site_name in Templates
By appending ?site_name={{ site_name }} to the URLs in the template, we ensure that the site_name 
is included in the query string of the generated links. This way, when users navigate from one view to another, 
the site_name is retained and passed along, allowing the views to correctly filter data based 
on the current site.

Summary
These modifications ensure that:

The site_name parameter is correctly retrieved from the URL or session.
The site_name is stored in the session to persist across different views.
The site_name is used to filter querysets where necessary.
The site_name is passed to templates and included in generated links, maintaining context
 as users navigate the site.
This approach ensures that the correct site data is displayed and retained as users interact
 with different parts of your application.






